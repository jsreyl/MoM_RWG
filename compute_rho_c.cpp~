#include"compute_rho_c.h"

void ComputeRho_c(Eigen::MatrixXd r_c, Eigen::MatrixXd& rho_c_pls, Eigen::MatrixXd& rho_c_mns){
  //Rho pls goes directed from the free vertex to the centre
  //Rho mns goes directed from the centre to the free vertex
  for(int i=0;i<NUM_DOFS;i++){//For each internal edge
    int elem_pls=EDGECONEXELEMS(i,0);//There are two triangles, one plus
    int elem_mns=EDGECONEXELEMS(i,1);//one minus
    //Each of them have a free vertex, we can use DOFLOCALNUMS, since the edge index is the same as the free vertex index
    int localnode_pls=LOCALVERTEX(DOFLOCALNUMS(i,0));
    int localnode_mns=LOCALVERTEX(DOFLOCALNUMS(i,1));
    //whose coordinates we want to know
    Eigen::Vector3d vertex_pls= NODE_COORD.row(ELEMENTS(elem_pls,localnode_pls));
    Eigen::Vector3d vertex_mns= NODE_COORD.row(ELEMENTS(elem_mns,localnode_mns));
    //Now the vector from the edge to the centre, remember r_c is the centre of the triangle, so we just substract vectors
    rho_c_pls(i)=r_c.row(elem_pls)-vertex_pls;
    rho_c_mns(i)=vertex_mns-r_c.row(elem_mns);
  }

}
